// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: AnalyzerReport.proto
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace SonarAnalyzer.Protobuf {

  /// <summary>Holder for reflection information generated from AnalyzerReport.proto</summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public static partial class AnalyzerReportReflection {

    #region Descriptor
    /// <summary>File descriptor for AnalyzerReport.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static AnalyzerReportReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "ChRBbmFseXplclJlcG9ydC5wcm90bxINc29uYXJhbmFseXplciJbCglUZXh0",
            "UmFuZ2USEgoKc3RhcnRfbGluZRgBIAEoBRIQCghlbmRfbGluZRgCIAEoBRIU",
            "CgxzdGFydF9vZmZzZXQYAyABKAUSEgoKZW5kX29mZnNldBgEIAEoBSLHAQoN",
            "VG9rZW5UeXBlSW5mbxIRCglmaWxlX3BhdGgYASABKAkSOgoKdG9rZW5faW5m",
            "bxgCIAMoCzImLnNvbmFyYW5hbHl6ZXIuVG9rZW5UeXBlSW5mby5Ub2tlbklu",
            "Zm8aZwoJVG9rZW5JbmZvEiwKCnRva2VuX3R5cGUYASABKA4yGC5zb25hcmFu",
            "YWx5emVyLlRva2VuVHlwZRIsCgp0ZXh0X3JhbmdlGAIgASgLMhguc29uYXJh",
            "bmFseXplci5UZXh0UmFuZ2Ui3gEKE1N5bWJvbFJlZmVyZW5jZUluZm8SEQoJ",
            "ZmlsZV9wYXRoGAEgASgJEkUKCXJlZmVyZW5jZRgCIAMoCzIyLnNvbmFyYW5h",
            "bHl6ZXIuU3ltYm9sUmVmZXJlbmNlSW5mby5TeW1ib2xSZWZlcmVuY2UabQoP",
            "U3ltYm9sUmVmZXJlbmNlEi0KC2RlY2xhcmF0aW9uGAEgASgLMhguc29uYXJh",
            "bmFseXplci5UZXh0UmFuZ2USKwoJcmVmZXJlbmNlGAIgAygLMhguc29uYXJh",
            "bmFseXplci5UZXh0UmFuZ2UiuAEKEkNvcHlQYXN0ZVRva2VuSW5mbxIRCglm",
            "aWxlX3BhdGgYASABKAkSPwoKdG9rZW5faW5mbxgCIAMoCzIrLnNvbmFyYW5h",
            "bHl6ZXIuQ29weVBhc3RlVG9rZW5JbmZvLlRva2VuSW5mbxpOCglUb2tlbklu",
            "Zm8SEwoLdG9rZW5fdmFsdWUYASABKAkSLAoKdGV4dF9yYW5nZRgCIAEoCzIY",
            "LnNvbmFyYW5hbHl6ZXIuVGV4dFJhbmdlIqcDCgtNZXRyaWNzSW5mbxIRCglm",
            "aWxlX3BhdGgYASABKAkSEgoKbGluZV9jb3VudBgCIAEoBRITCgtjbGFzc19j",
            "b3VudBgDIAEoBRIXCg9zdGF0ZW1lbnRfY291bnQYBCABKAUSFgoOZnVuY3Rp",
            "b25fY291bnQYBSABKAUSGAoQcHVibGljX2FwaV9jb3VudBgGIAEoBRIlCh1w",
            "dWJsaWNfdW5kb2N1bWVudGVkX2FwaV9jb3VudBgHIAEoBRISCgpjb21wbGV4",
            "aXR5GAggASgFEh0KFWNvbXBsZXhpdHlfaW5fY2xhc3NlcxgJIAEoBRIfChdj",
            "b21wbGV4aXR5X2luX2Z1bmN0aW9ucxgKIAEoBRIkChxmaWxlX2NvbXBsZXhp",
            "dHlfZGlzdHJpYnV0aW9uGAsgASgJEigKIGZ1bmN0aW9uX2NvbXBsZXhpdHlf",
            "ZGlzdHJpYnV0aW9uGAwgASgJEhgKEG5vX3NvbmFyX2NvbW1lbnQYDSADKAUS",
            "GQoRbm9uX2JsYW5rX2NvbW1lbnQYDiADKAUSEQoJY29kZV9saW5lGA8gAygF",
            "IqEBCgpGaWxlSXNzdWVzEhEKCWZpbGVfcGF0aBgBIAEoCRIuCgVpc3N1ZRgC",
            "IAMoCzIfLnNvbmFyYW5hbHl6ZXIuRmlsZUlzc3Vlcy5Jc3N1ZRpQCgVJc3N1",
            "ZRIKCgJpZBgBIAEoCRIPCgdtZXNzYWdlGAIgASgJEioKCGxvY2F0aW9uGAMg",
            "ASgLMhguc29uYXJhbmFseXplci5UZXh0UmFuZ2UqagoJVG9rZW5UeXBlEgsK",
            "B1VOS05PV04QABINCglUWVBFX05BTUUQARITCg9OVU1FUklDX0xJVEVSQUwQ",
            "AhISCg5TVFJJTkdfTElURVJBTBADEgsKB0tFWVdPUkQQBBILCgdDT01NRU5U",
            "EAVCSwofb3JnLnNvbmFyc291cmNlLmRvdG5ldC5wcm90b2J1ZkINU29uYXJB",
            "bmFseXplckgBqgIWU29uYXJBbmFseXplci5Qcm90b2J1ZmIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::SonarAnalyzer.Protobuf.TokenType), }, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::SonarAnalyzer.Protobuf.TextRange), global::SonarAnalyzer.Protobuf.TextRange.Parser, new[]{ "StartLine", "EndLine", "StartOffset", "EndOffset" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::SonarAnalyzer.Protobuf.TokenTypeInfo), global::SonarAnalyzer.Protobuf.TokenTypeInfo.Parser, new[]{ "FilePath", "TokenInfo" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::SonarAnalyzer.Protobuf.TokenTypeInfo.Types.TokenInfo), global::SonarAnalyzer.Protobuf.TokenTypeInfo.Types.TokenInfo.Parser, new[]{ "TokenType", "TextRange" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::SonarAnalyzer.Protobuf.SymbolReferenceInfo), global::SonarAnalyzer.Protobuf.SymbolReferenceInfo.Parser, new[]{ "FilePath", "Reference" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::SonarAnalyzer.Protobuf.SymbolReferenceInfo.Types.SymbolReference), global::SonarAnalyzer.Protobuf.SymbolReferenceInfo.Types.SymbolReference.Parser, new[]{ "Declaration", "Reference" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::SonarAnalyzer.Protobuf.CopyPasteTokenInfo), global::SonarAnalyzer.Protobuf.CopyPasteTokenInfo.Parser, new[]{ "FilePath", "TokenInfo" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::SonarAnalyzer.Protobuf.CopyPasteTokenInfo.Types.TokenInfo), global::SonarAnalyzer.Protobuf.CopyPasteTokenInfo.Types.TokenInfo.Parser, new[]{ "TokenValue", "TextRange" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::SonarAnalyzer.Protobuf.MetricsInfo), global::SonarAnalyzer.Protobuf.MetricsInfo.Parser, new[]{ "FilePath", "LineCount", "ClassCount", "StatementCount", "FunctionCount", "PublicApiCount", "PublicUndocumentedApiCount", "Complexity", "ComplexityInClasses", "ComplexityInFunctions", "FileComplexityDistribution", "FunctionComplexityDistribution", "NoSonarComment", "NonBlankComment", "CodeLine" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::SonarAnalyzer.Protobuf.FileIssues), global::SonarAnalyzer.Protobuf.FileIssues.Parser, new[]{ "FilePath", "Issue" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::SonarAnalyzer.Protobuf.FileIssues.Types.Issue), global::SonarAnalyzer.Protobuf.FileIssues.Types.Issue.Parser, new[]{ "Id", "Message", "Location" }, null, null, null)})
          }));
    }
    #endregion

  }
  #region Enums
  public enum TokenType {
    [pbr::OriginalName("UNKNOWN")] Unknown = 0,
    [pbr::OriginalName("TYPE_NAME")] TypeName = 1,
    [pbr::OriginalName("NUMERIC_LITERAL")] NumericLiteral = 2,
    [pbr::OriginalName("STRING_LITERAL")] StringLiteral = 3,
    [pbr::OriginalName("KEYWORD")] Keyword = 4,
    [pbr::OriginalName("COMMENT")] Comment = 5,
  }

  #endregion

  #region Messages
  /// <summary>
  ///  Lines start at 1 and line offsets start at 0
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class TextRange : pb::IMessage<TextRange> {
    private static readonly pb::MessageParser<TextRange> _parser = new pb::MessageParser<TextRange>(() => new TextRange());
    public static pb::MessageParser<TextRange> Parser { get { return _parser; } }

    public static pbr::MessageDescriptor Descriptor {
      get { return global::SonarAnalyzer.Protobuf.AnalyzerReportReflection.Descriptor.MessageTypes[0]; }
    }

    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    public TextRange() {
      OnConstruction();
    }

    partial void OnConstruction();

    public TextRange(TextRange other) : this() {
      startLine_ = other.startLine_;
      endLine_ = other.endLine_;
      startOffset_ = other.startOffset_;
      endOffset_ = other.endOffset_;
    }

    public TextRange Clone() {
      return new TextRange(this);
    }

    /// <summary>Field number for the "start_line" field.</summary>
    public const int StartLineFieldNumber = 1;
    private int startLine_;
    public int StartLine {
      get { return startLine_; }
      set {
        startLine_ = value;
      }
    }

    /// <summary>Field number for the "end_line" field.</summary>
    public const int EndLineFieldNumber = 2;
    private int endLine_;
    /// <summary>
    ///  End line (inclusive)
    /// </summary>
    public int EndLine {
      get { return endLine_; }
      set {
        endLine_ = value;
      }
    }

    /// <summary>Field number for the "start_offset" field.</summary>
    public const int StartOffsetFieldNumber = 3;
    private int startOffset_;
    public int StartOffset {
      get { return startOffset_; }
      set {
        startOffset_ = value;
      }
    }

    /// <summary>Field number for the "end_offset" field.</summary>
    public const int EndOffsetFieldNumber = 4;
    private int endOffset_;
    public int EndOffset {
      get { return endOffset_; }
      set {
        endOffset_ = value;
      }
    }

    public override bool Equals(object other) {
      return Equals(other as TextRange);
    }

    public bool Equals(TextRange other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (StartLine != other.StartLine) return false;
      if (EndLine != other.EndLine) return false;
      if (StartOffset != other.StartOffset) return false;
      if (EndOffset != other.EndOffset) return false;
      return true;
    }

    public override int GetHashCode() {
      int hash = 1;
      if (StartLine != 0) hash ^= StartLine.GetHashCode();
      if (EndLine != 0) hash ^= EndLine.GetHashCode();
      if (StartOffset != 0) hash ^= StartOffset.GetHashCode();
      if (EndOffset != 0) hash ^= EndOffset.GetHashCode();
      return hash;
    }

    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (StartLine != 0) {
        output.WriteRawTag(8);
        output.WriteInt32(StartLine);
      }
      if (EndLine != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(EndLine);
      }
      if (StartOffset != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(StartOffset);
      }
      if (EndOffset != 0) {
        output.WriteRawTag(32);
        output.WriteInt32(EndOffset);
      }
    }

    public int CalculateSize() {
      int size = 0;
      if (StartLine != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(StartLine);
      }
      if (EndLine != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(EndLine);
      }
      if (StartOffset != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(StartOffset);
      }
      if (EndOffset != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(EndOffset);
      }
      return size;
    }

    public void MergeFrom(TextRange other) {
      if (other == null) {
        return;
      }
      if (other.StartLine != 0) {
        StartLine = other.StartLine;
      }
      if (other.EndLine != 0) {
        EndLine = other.EndLine;
      }
      if (other.StartOffset != 0) {
        StartOffset = other.StartOffset;
      }
      if (other.EndOffset != 0) {
        EndOffset = other.EndOffset;
      }
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            StartLine = input.ReadInt32();
            break;
          }
          case 16: {
            EndLine = input.ReadInt32();
            break;
          }
          case 24: {
            StartOffset = input.ReadInt32();
            break;
          }
          case 32: {
            EndOffset = input.ReadInt32();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  Used for code coloring
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class TokenTypeInfo : pb::IMessage<TokenTypeInfo> {
    private static readonly pb::MessageParser<TokenTypeInfo> _parser = new pb::MessageParser<TokenTypeInfo>(() => new TokenTypeInfo());
    public static pb::MessageParser<TokenTypeInfo> Parser { get { return _parser; } }

    public static pbr::MessageDescriptor Descriptor {
      get { return global::SonarAnalyzer.Protobuf.AnalyzerReportReflection.Descriptor.MessageTypes[1]; }
    }

    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    public TokenTypeInfo() {
      OnConstruction();
    }

    partial void OnConstruction();

    public TokenTypeInfo(TokenTypeInfo other) : this() {
      filePath_ = other.filePath_;
      tokenInfo_ = other.tokenInfo_.Clone();
    }

    public TokenTypeInfo Clone() {
      return new TokenTypeInfo(this);
    }

    /// <summary>Field number for the "file_path" field.</summary>
    public const int FilePathFieldNumber = 1;
    private string filePath_ = "";
    public string FilePath {
      get { return filePath_; }
      set {
        filePath_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "token_info" field.</summary>
    public const int TokenInfoFieldNumber = 2;
    private static readonly pb::FieldCodec<global::SonarAnalyzer.Protobuf.TokenTypeInfo.Types.TokenInfo> _repeated_tokenInfo_codec
        = pb::FieldCodec.ForMessage(18, global::SonarAnalyzer.Protobuf.TokenTypeInfo.Types.TokenInfo.Parser);
    private readonly pbc::RepeatedField<global::SonarAnalyzer.Protobuf.TokenTypeInfo.Types.TokenInfo> tokenInfo_ = new pbc::RepeatedField<global::SonarAnalyzer.Protobuf.TokenTypeInfo.Types.TokenInfo>();
    public pbc::RepeatedField<global::SonarAnalyzer.Protobuf.TokenTypeInfo.Types.TokenInfo> TokenInfo {
      get { return tokenInfo_; }
    }

    public override bool Equals(object other) {
      return Equals(other as TokenTypeInfo);
    }

    public bool Equals(TokenTypeInfo other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (FilePath != other.FilePath) return false;
      if(!tokenInfo_.Equals(other.tokenInfo_)) return false;
      return true;
    }

    public override int GetHashCode() {
      int hash = 1;
      if (FilePath.Length != 0) hash ^= FilePath.GetHashCode();
      hash ^= tokenInfo_.GetHashCode();
      return hash;
    }

    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (FilePath.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(FilePath);
      }
      tokenInfo_.WriteTo(output, _repeated_tokenInfo_codec);
    }

    public int CalculateSize() {
      int size = 0;
      if (FilePath.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FilePath);
      }
      size += tokenInfo_.CalculateSize(_repeated_tokenInfo_codec);
      return size;
    }

    public void MergeFrom(TokenTypeInfo other) {
      if (other == null) {
        return;
      }
      if (other.FilePath.Length != 0) {
        FilePath = other.FilePath;
      }
      tokenInfo_.Add(other.tokenInfo_);
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            FilePath = input.ReadString();
            break;
          }
          case 18: {
            tokenInfo_.AddEntriesFrom(input, _repeated_tokenInfo_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the TokenTypeInfo message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public static partial class Types {
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class TokenInfo : pb::IMessage<TokenInfo> {
        private static readonly pb::MessageParser<TokenInfo> _parser = new pb::MessageParser<TokenInfo>(() => new TokenInfo());
        public static pb::MessageParser<TokenInfo> Parser { get { return _parser; } }

        public static pbr::MessageDescriptor Descriptor {
          get { return global::SonarAnalyzer.Protobuf.TokenTypeInfo.Descriptor.NestedTypes[0]; }
        }

        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        public TokenInfo() {
          OnConstruction();
        }

        partial void OnConstruction();

        public TokenInfo(TokenInfo other) : this() {
          tokenType_ = other.tokenType_;
          TextRange = other.textRange_ != null ? other.TextRange.Clone() : null;
        }

        public TokenInfo Clone() {
          return new TokenInfo(this);
        }

        /// <summary>Field number for the "token_type" field.</summary>
        public const int TokenTypeFieldNumber = 1;
        private global::SonarAnalyzer.Protobuf.TokenType tokenType_ = 0;
        public global::SonarAnalyzer.Protobuf.TokenType TokenType {
          get { return tokenType_; }
          set {
            tokenType_ = value;
          }
        }

        /// <summary>Field number for the "text_range" field.</summary>
        public const int TextRangeFieldNumber = 2;
        private global::SonarAnalyzer.Protobuf.TextRange textRange_;
        public global::SonarAnalyzer.Protobuf.TextRange TextRange {
          get { return textRange_; }
          set {
            textRange_ = value;
          }
        }

        public override bool Equals(object other) {
          return Equals(other as TokenInfo);
        }

        public bool Equals(TokenInfo other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (TokenType != other.TokenType) return false;
          if (!object.Equals(TextRange, other.TextRange)) return false;
          return true;
        }

        public override int GetHashCode() {
          int hash = 1;
          if (TokenType != 0) hash ^= TokenType.GetHashCode();
          if (textRange_ != null) hash ^= TextRange.GetHashCode();
          return hash;
        }

        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        public void WriteTo(pb::CodedOutputStream output) {
          if (TokenType != 0) {
            output.WriteRawTag(8);
            output.WriteEnum((int) TokenType);
          }
          if (textRange_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(TextRange);
          }
        }

        public int CalculateSize() {
          int size = 0;
          if (TokenType != 0) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) TokenType);
          }
          if (textRange_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(TextRange);
          }
          return size;
        }

        public void MergeFrom(TokenInfo other) {
          if (other == null) {
            return;
          }
          if (other.TokenType != 0) {
            TokenType = other.TokenType;
          }
          if (other.textRange_ != null) {
            if (textRange_ == null) {
              textRange_ = new global::SonarAnalyzer.Protobuf.TextRange();
            }
            TextRange.MergeFrom(other.TextRange);
          }
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 8: {
                tokenType_ = (global::SonarAnalyzer.Protobuf.TokenType) input.ReadEnum();
                break;
              }
              case 18: {
                if (textRange_ == null) {
                  textRange_ = new global::SonarAnalyzer.Protobuf.TextRange();
                }
                input.ReadMessage(textRange_);
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  ///  Used for symbol reference highlighting
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class SymbolReferenceInfo : pb::IMessage<SymbolReferenceInfo> {
    private static readonly pb::MessageParser<SymbolReferenceInfo> _parser = new pb::MessageParser<SymbolReferenceInfo>(() => new SymbolReferenceInfo());
    public static pb::MessageParser<SymbolReferenceInfo> Parser { get { return _parser; } }

    public static pbr::MessageDescriptor Descriptor {
      get { return global::SonarAnalyzer.Protobuf.AnalyzerReportReflection.Descriptor.MessageTypes[2]; }
    }

    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    public SymbolReferenceInfo() {
      OnConstruction();
    }

    partial void OnConstruction();

    public SymbolReferenceInfo(SymbolReferenceInfo other) : this() {
      filePath_ = other.filePath_;
      reference_ = other.reference_.Clone();
    }

    public SymbolReferenceInfo Clone() {
      return new SymbolReferenceInfo(this);
    }

    /// <summary>Field number for the "file_path" field.</summary>
    public const int FilePathFieldNumber = 1;
    private string filePath_ = "";
    public string FilePath {
      get { return filePath_; }
      set {
        filePath_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "reference" field.</summary>
    public const int ReferenceFieldNumber = 2;
    private static readonly pb::FieldCodec<global::SonarAnalyzer.Protobuf.SymbolReferenceInfo.Types.SymbolReference> _repeated_reference_codec
        = pb::FieldCodec.ForMessage(18, global::SonarAnalyzer.Protobuf.SymbolReferenceInfo.Types.SymbolReference.Parser);
    private readonly pbc::RepeatedField<global::SonarAnalyzer.Protobuf.SymbolReferenceInfo.Types.SymbolReference> reference_ = new pbc::RepeatedField<global::SonarAnalyzer.Protobuf.SymbolReferenceInfo.Types.SymbolReference>();
    public pbc::RepeatedField<global::SonarAnalyzer.Protobuf.SymbolReferenceInfo.Types.SymbolReference> Reference {
      get { return reference_; }
    }

    public override bool Equals(object other) {
      return Equals(other as SymbolReferenceInfo);
    }

    public bool Equals(SymbolReferenceInfo other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (FilePath != other.FilePath) return false;
      if(!reference_.Equals(other.reference_)) return false;
      return true;
    }

    public override int GetHashCode() {
      int hash = 1;
      if (FilePath.Length != 0) hash ^= FilePath.GetHashCode();
      hash ^= reference_.GetHashCode();
      return hash;
    }

    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (FilePath.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(FilePath);
      }
      reference_.WriteTo(output, _repeated_reference_codec);
    }

    public int CalculateSize() {
      int size = 0;
      if (FilePath.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FilePath);
      }
      size += reference_.CalculateSize(_repeated_reference_codec);
      return size;
    }

    public void MergeFrom(SymbolReferenceInfo other) {
      if (other == null) {
        return;
      }
      if (other.FilePath.Length != 0) {
        FilePath = other.FilePath;
      }
      reference_.Add(other.reference_);
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            FilePath = input.ReadString();
            break;
          }
          case 18: {
            reference_.AddEntriesFrom(input, _repeated_reference_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the SymbolReferenceInfo message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public static partial class Types {
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class SymbolReference : pb::IMessage<SymbolReference> {
        private static readonly pb::MessageParser<SymbolReference> _parser = new pb::MessageParser<SymbolReference>(() => new SymbolReference());
        public static pb::MessageParser<SymbolReference> Parser { get { return _parser; } }

        public static pbr::MessageDescriptor Descriptor {
          get { return global::SonarAnalyzer.Protobuf.SymbolReferenceInfo.Descriptor.NestedTypes[0]; }
        }

        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        public SymbolReference() {
          OnConstruction();
        }

        partial void OnConstruction();

        public SymbolReference(SymbolReference other) : this() {
          Declaration = other.declaration_ != null ? other.Declaration.Clone() : null;
          reference_ = other.reference_.Clone();
        }

        public SymbolReference Clone() {
          return new SymbolReference(this);
        }

        /// <summary>Field number for the "declaration" field.</summary>
        public const int DeclarationFieldNumber = 1;
        private global::SonarAnalyzer.Protobuf.TextRange declaration_;
        public global::SonarAnalyzer.Protobuf.TextRange Declaration {
          get { return declaration_; }
          set {
            declaration_ = value;
          }
        }

        /// <summary>Field number for the "reference" field.</summary>
        public const int ReferenceFieldNumber = 2;
        private static readonly pb::FieldCodec<global::SonarAnalyzer.Protobuf.TextRange> _repeated_reference_codec
            = pb::FieldCodec.ForMessage(18, global::SonarAnalyzer.Protobuf.TextRange.Parser);
        private readonly pbc::RepeatedField<global::SonarAnalyzer.Protobuf.TextRange> reference_ = new pbc::RepeatedField<global::SonarAnalyzer.Protobuf.TextRange>();
        public pbc::RepeatedField<global::SonarAnalyzer.Protobuf.TextRange> Reference {
          get { return reference_; }
        }

        public override bool Equals(object other) {
          return Equals(other as SymbolReference);
        }

        public bool Equals(SymbolReference other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(Declaration, other.Declaration)) return false;
          if(!reference_.Equals(other.reference_)) return false;
          return true;
        }

        public override int GetHashCode() {
          int hash = 1;
          if (declaration_ != null) hash ^= Declaration.GetHashCode();
          hash ^= reference_.GetHashCode();
          return hash;
        }

        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        public void WriteTo(pb::CodedOutputStream output) {
          if (declaration_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(Declaration);
          }
          reference_.WriteTo(output, _repeated_reference_codec);
        }

        public int CalculateSize() {
          int size = 0;
          if (declaration_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Declaration);
          }
          size += reference_.CalculateSize(_repeated_reference_codec);
          return size;
        }

        public void MergeFrom(SymbolReference other) {
          if (other == null) {
            return;
          }
          if (other.declaration_ != null) {
            if (declaration_ == null) {
              declaration_ = new global::SonarAnalyzer.Protobuf.TextRange();
            }
            Declaration.MergeFrom(other.Declaration);
          }
          reference_.Add(other.reference_);
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                if (declaration_ == null) {
                  declaration_ = new global::SonarAnalyzer.Protobuf.TextRange();
                }
                input.ReadMessage(declaration_);
                break;
              }
              case 18: {
                reference_.AddEntriesFrom(input, _repeated_reference_codec);
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  ///  Used for copy-paste detection
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class CopyPasteTokenInfo : pb::IMessage<CopyPasteTokenInfo> {
    private static readonly pb::MessageParser<CopyPasteTokenInfo> _parser = new pb::MessageParser<CopyPasteTokenInfo>(() => new CopyPasteTokenInfo());
    public static pb::MessageParser<CopyPasteTokenInfo> Parser { get { return _parser; } }

    public static pbr::MessageDescriptor Descriptor {
      get { return global::SonarAnalyzer.Protobuf.AnalyzerReportReflection.Descriptor.MessageTypes[3]; }
    }

    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    public CopyPasteTokenInfo() {
      OnConstruction();
    }

    partial void OnConstruction();

    public CopyPasteTokenInfo(CopyPasteTokenInfo other) : this() {
      filePath_ = other.filePath_;
      tokenInfo_ = other.tokenInfo_.Clone();
    }

    public CopyPasteTokenInfo Clone() {
      return new CopyPasteTokenInfo(this);
    }

    /// <summary>Field number for the "file_path" field.</summary>
    public const int FilePathFieldNumber = 1;
    private string filePath_ = "";
    public string FilePath {
      get { return filePath_; }
      set {
        filePath_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "token_info" field.</summary>
    public const int TokenInfoFieldNumber = 2;
    private static readonly pb::FieldCodec<global::SonarAnalyzer.Protobuf.CopyPasteTokenInfo.Types.TokenInfo> _repeated_tokenInfo_codec
        = pb::FieldCodec.ForMessage(18, global::SonarAnalyzer.Protobuf.CopyPasteTokenInfo.Types.TokenInfo.Parser);
    private readonly pbc::RepeatedField<global::SonarAnalyzer.Protobuf.CopyPasteTokenInfo.Types.TokenInfo> tokenInfo_ = new pbc::RepeatedField<global::SonarAnalyzer.Protobuf.CopyPasteTokenInfo.Types.TokenInfo>();
    public pbc::RepeatedField<global::SonarAnalyzer.Protobuf.CopyPasteTokenInfo.Types.TokenInfo> TokenInfo {
      get { return tokenInfo_; }
    }

    public override bool Equals(object other) {
      return Equals(other as CopyPasteTokenInfo);
    }

    public bool Equals(CopyPasteTokenInfo other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (FilePath != other.FilePath) return false;
      if(!tokenInfo_.Equals(other.tokenInfo_)) return false;
      return true;
    }

    public override int GetHashCode() {
      int hash = 1;
      if (FilePath.Length != 0) hash ^= FilePath.GetHashCode();
      hash ^= tokenInfo_.GetHashCode();
      return hash;
    }

    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (FilePath.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(FilePath);
      }
      tokenInfo_.WriteTo(output, _repeated_tokenInfo_codec);
    }

    public int CalculateSize() {
      int size = 0;
      if (FilePath.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FilePath);
      }
      size += tokenInfo_.CalculateSize(_repeated_tokenInfo_codec);
      return size;
    }

    public void MergeFrom(CopyPasteTokenInfo other) {
      if (other == null) {
        return;
      }
      if (other.FilePath.Length != 0) {
        FilePath = other.FilePath;
      }
      tokenInfo_.Add(other.tokenInfo_);
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            FilePath = input.ReadString();
            break;
          }
          case 18: {
            tokenInfo_.AddEntriesFrom(input, _repeated_tokenInfo_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the CopyPasteTokenInfo message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public static partial class Types {
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class TokenInfo : pb::IMessage<TokenInfo> {
        private static readonly pb::MessageParser<TokenInfo> _parser = new pb::MessageParser<TokenInfo>(() => new TokenInfo());
        public static pb::MessageParser<TokenInfo> Parser { get { return _parser; } }

        public static pbr::MessageDescriptor Descriptor {
          get { return global::SonarAnalyzer.Protobuf.CopyPasteTokenInfo.Descriptor.NestedTypes[0]; }
        }

        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        public TokenInfo() {
          OnConstruction();
        }

        partial void OnConstruction();

        public TokenInfo(TokenInfo other) : this() {
          tokenValue_ = other.tokenValue_;
          TextRange = other.textRange_ != null ? other.TextRange.Clone() : null;
        }

        public TokenInfo Clone() {
          return new TokenInfo(this);
        }

        /// <summary>Field number for the "token_value" field.</summary>
        public const int TokenValueFieldNumber = 1;
        private string tokenValue_ = "";
        public string TokenValue {
          get { return tokenValue_; }
          set {
            tokenValue_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "text_range" field.</summary>
        public const int TextRangeFieldNumber = 2;
        private global::SonarAnalyzer.Protobuf.TextRange textRange_;
        public global::SonarAnalyzer.Protobuf.TextRange TextRange {
          get { return textRange_; }
          set {
            textRange_ = value;
          }
        }

        public override bool Equals(object other) {
          return Equals(other as TokenInfo);
        }

        public bool Equals(TokenInfo other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (TokenValue != other.TokenValue) return false;
          if (!object.Equals(TextRange, other.TextRange)) return false;
          return true;
        }

        public override int GetHashCode() {
          int hash = 1;
          if (TokenValue.Length != 0) hash ^= TokenValue.GetHashCode();
          if (textRange_ != null) hash ^= TextRange.GetHashCode();
          return hash;
        }

        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        public void WriteTo(pb::CodedOutputStream output) {
          if (TokenValue.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(TokenValue);
          }
          if (textRange_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(TextRange);
          }
        }

        public int CalculateSize() {
          int size = 0;
          if (TokenValue.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(TokenValue);
          }
          if (textRange_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(TextRange);
          }
          return size;
        }

        public void MergeFrom(TokenInfo other) {
          if (other == null) {
            return;
          }
          if (other.TokenValue.Length != 0) {
            TokenValue = other.TokenValue;
          }
          if (other.textRange_ != null) {
            if (textRange_ == null) {
              textRange_ = new global::SonarAnalyzer.Protobuf.TextRange();
            }
            TextRange.MergeFrom(other.TextRange);
          }
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                TokenValue = input.ReadString();
                break;
              }
              case 18: {
                if (textRange_ == null) {
                  textRange_ = new global::SonarAnalyzer.Protobuf.TextRange();
                }
                input.ReadMessage(textRange_);
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  ///  Metrics reporting
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class MetricsInfo : pb::IMessage<MetricsInfo> {
    private static readonly pb::MessageParser<MetricsInfo> _parser = new pb::MessageParser<MetricsInfo>(() => new MetricsInfo());
    public static pb::MessageParser<MetricsInfo> Parser { get { return _parser; } }

    public static pbr::MessageDescriptor Descriptor {
      get { return global::SonarAnalyzer.Protobuf.AnalyzerReportReflection.Descriptor.MessageTypes[4]; }
    }

    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    public MetricsInfo() {
      OnConstruction();
    }

    partial void OnConstruction();

    public MetricsInfo(MetricsInfo other) : this() {
      filePath_ = other.filePath_;
      lineCount_ = other.lineCount_;
      classCount_ = other.classCount_;
      statementCount_ = other.statementCount_;
      functionCount_ = other.functionCount_;
      publicApiCount_ = other.publicApiCount_;
      publicUndocumentedApiCount_ = other.publicUndocumentedApiCount_;
      complexity_ = other.complexity_;
      complexityInClasses_ = other.complexityInClasses_;
      complexityInFunctions_ = other.complexityInFunctions_;
      fileComplexityDistribution_ = other.fileComplexityDistribution_;
      functionComplexityDistribution_ = other.functionComplexityDistribution_;
      noSonarComment_ = other.noSonarComment_.Clone();
      nonBlankComment_ = other.nonBlankComment_.Clone();
      codeLine_ = other.codeLine_.Clone();
    }

    public MetricsInfo Clone() {
      return new MetricsInfo(this);
    }

    /// <summary>Field number for the "file_path" field.</summary>
    public const int FilePathFieldNumber = 1;
    private string filePath_ = "";
    public string FilePath {
      get { return filePath_; }
      set {
        filePath_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "line_count" field.</summary>
    public const int LineCountFieldNumber = 2;
    private int lineCount_;
    public int LineCount {
      get { return lineCount_; }
      set {
        lineCount_ = value;
      }
    }

    /// <summary>Field number for the "class_count" field.</summary>
    public const int ClassCountFieldNumber = 3;
    private int classCount_;
    public int ClassCount {
      get { return classCount_; }
      set {
        classCount_ = value;
      }
    }

    /// <summary>Field number for the "statement_count" field.</summary>
    public const int StatementCountFieldNumber = 4;
    private int statementCount_;
    public int StatementCount {
      get { return statementCount_; }
      set {
        statementCount_ = value;
      }
    }

    /// <summary>Field number for the "function_count" field.</summary>
    public const int FunctionCountFieldNumber = 5;
    private int functionCount_;
    public int FunctionCount {
      get { return functionCount_; }
      set {
        functionCount_ = value;
      }
    }

    /// <summary>Field number for the "public_api_count" field.</summary>
    public const int PublicApiCountFieldNumber = 6;
    private int publicApiCount_;
    public int PublicApiCount {
      get { return publicApiCount_; }
      set {
        publicApiCount_ = value;
      }
    }

    /// <summary>Field number for the "public_undocumented_api_count" field.</summary>
    public const int PublicUndocumentedApiCountFieldNumber = 7;
    private int publicUndocumentedApiCount_;
    public int PublicUndocumentedApiCount {
      get { return publicUndocumentedApiCount_; }
      set {
        publicUndocumentedApiCount_ = value;
      }
    }

    /// <summary>Field number for the "complexity" field.</summary>
    public const int ComplexityFieldNumber = 8;
    private int complexity_;
    public int Complexity {
      get { return complexity_; }
      set {
        complexity_ = value;
      }
    }

    /// <summary>Field number for the "complexity_in_classes" field.</summary>
    public const int ComplexityInClassesFieldNumber = 9;
    private int complexityInClasses_;
    public int ComplexityInClasses {
      get { return complexityInClasses_; }
      set {
        complexityInClasses_ = value;
      }
    }

    /// <summary>Field number for the "complexity_in_functions" field.</summary>
    public const int ComplexityInFunctionsFieldNumber = 10;
    private int complexityInFunctions_;
    public int ComplexityInFunctions {
      get { return complexityInFunctions_; }
      set {
        complexityInFunctions_ = value;
      }
    }

    /// <summary>Field number for the "file_complexity_distribution" field.</summary>
    public const int FileComplexityDistributionFieldNumber = 11;
    private string fileComplexityDistribution_ = "";
    public string FileComplexityDistribution {
      get { return fileComplexityDistribution_; }
      set {
        fileComplexityDistribution_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "function_complexity_distribution" field.</summary>
    public const int FunctionComplexityDistributionFieldNumber = 12;
    private string functionComplexityDistribution_ = "";
    public string FunctionComplexityDistribution {
      get { return functionComplexityDistribution_; }
      set {
        functionComplexityDistribution_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "no_sonar_comment" field.</summary>
    public const int NoSonarCommentFieldNumber = 13;
    private static readonly pb::FieldCodec<int> _repeated_noSonarComment_codec
        = pb::FieldCodec.ForInt32(106);
    private readonly pbc::RepeatedField<int> noSonarComment_ = new pbc::RepeatedField<int>();
    public pbc::RepeatedField<int> NoSonarComment {
      get { return noSonarComment_; }
    }

    /// <summary>Field number for the "non_blank_comment" field.</summary>
    public const int NonBlankCommentFieldNumber = 14;
    private static readonly pb::FieldCodec<int> _repeated_nonBlankComment_codec
        = pb::FieldCodec.ForInt32(114);
    private readonly pbc::RepeatedField<int> nonBlankComment_ = new pbc::RepeatedField<int>();
    public pbc::RepeatedField<int> NonBlankComment {
      get { return nonBlankComment_; }
    }

    /// <summary>Field number for the "code_line" field.</summary>
    public const int CodeLineFieldNumber = 15;
    private static readonly pb::FieldCodec<int> _repeated_codeLine_codec
        = pb::FieldCodec.ForInt32(122);
    private readonly pbc::RepeatedField<int> codeLine_ = new pbc::RepeatedField<int>();
    public pbc::RepeatedField<int> CodeLine {
      get { return codeLine_; }
    }

    public override bool Equals(object other) {
      return Equals(other as MetricsInfo);
    }

    public bool Equals(MetricsInfo other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (FilePath != other.FilePath) return false;
      if (LineCount != other.LineCount) return false;
      if (ClassCount != other.ClassCount) return false;
      if (StatementCount != other.StatementCount) return false;
      if (FunctionCount != other.FunctionCount) return false;
      if (PublicApiCount != other.PublicApiCount) return false;
      if (PublicUndocumentedApiCount != other.PublicUndocumentedApiCount) return false;
      if (Complexity != other.Complexity) return false;
      if (ComplexityInClasses != other.ComplexityInClasses) return false;
      if (ComplexityInFunctions != other.ComplexityInFunctions) return false;
      if (FileComplexityDistribution != other.FileComplexityDistribution) return false;
      if (FunctionComplexityDistribution != other.FunctionComplexityDistribution) return false;
      if(!noSonarComment_.Equals(other.noSonarComment_)) return false;
      if(!nonBlankComment_.Equals(other.nonBlankComment_)) return false;
      if(!codeLine_.Equals(other.codeLine_)) return false;
      return true;
    }

    public override int GetHashCode() {
      int hash = 1;
      if (FilePath.Length != 0) hash ^= FilePath.GetHashCode();
      if (LineCount != 0) hash ^= LineCount.GetHashCode();
      if (ClassCount != 0) hash ^= ClassCount.GetHashCode();
      if (StatementCount != 0) hash ^= StatementCount.GetHashCode();
      if (FunctionCount != 0) hash ^= FunctionCount.GetHashCode();
      if (PublicApiCount != 0) hash ^= PublicApiCount.GetHashCode();
      if (PublicUndocumentedApiCount != 0) hash ^= PublicUndocumentedApiCount.GetHashCode();
      if (Complexity != 0) hash ^= Complexity.GetHashCode();
      if (ComplexityInClasses != 0) hash ^= ComplexityInClasses.GetHashCode();
      if (ComplexityInFunctions != 0) hash ^= ComplexityInFunctions.GetHashCode();
      if (FileComplexityDistribution.Length != 0) hash ^= FileComplexityDistribution.GetHashCode();
      if (FunctionComplexityDistribution.Length != 0) hash ^= FunctionComplexityDistribution.GetHashCode();
      hash ^= noSonarComment_.GetHashCode();
      hash ^= nonBlankComment_.GetHashCode();
      hash ^= codeLine_.GetHashCode();
      return hash;
    }

    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (FilePath.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(FilePath);
      }
      if (LineCount != 0) {
        output.WriteRawTag(16);
        output.WriteInt32(LineCount);
      }
      if (ClassCount != 0) {
        output.WriteRawTag(24);
        output.WriteInt32(ClassCount);
      }
      if (StatementCount != 0) {
        output.WriteRawTag(32);
        output.WriteInt32(StatementCount);
      }
      if (FunctionCount != 0) {
        output.WriteRawTag(40);
        output.WriteInt32(FunctionCount);
      }
      if (PublicApiCount != 0) {
        output.WriteRawTag(48);
        output.WriteInt32(PublicApiCount);
      }
      if (PublicUndocumentedApiCount != 0) {
        output.WriteRawTag(56);
        output.WriteInt32(PublicUndocumentedApiCount);
      }
      if (Complexity != 0) {
        output.WriteRawTag(64);
        output.WriteInt32(Complexity);
      }
      if (ComplexityInClasses != 0) {
        output.WriteRawTag(72);
        output.WriteInt32(ComplexityInClasses);
      }
      if (ComplexityInFunctions != 0) {
        output.WriteRawTag(80);
        output.WriteInt32(ComplexityInFunctions);
      }
      if (FileComplexityDistribution.Length != 0) {
        output.WriteRawTag(90);
        output.WriteString(FileComplexityDistribution);
      }
      if (FunctionComplexityDistribution.Length != 0) {
        output.WriteRawTag(98);
        output.WriteString(FunctionComplexityDistribution);
      }
      noSonarComment_.WriteTo(output, _repeated_noSonarComment_codec);
      nonBlankComment_.WriteTo(output, _repeated_nonBlankComment_codec);
      codeLine_.WriteTo(output, _repeated_codeLine_codec);
    }

    public int CalculateSize() {
      int size = 0;
      if (FilePath.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FilePath);
      }
      if (LineCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(LineCount);
      }
      if (ClassCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(ClassCount);
      }
      if (StatementCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(StatementCount);
      }
      if (FunctionCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(FunctionCount);
      }
      if (PublicApiCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(PublicApiCount);
      }
      if (PublicUndocumentedApiCount != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(PublicUndocumentedApiCount);
      }
      if (Complexity != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(Complexity);
      }
      if (ComplexityInClasses != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(ComplexityInClasses);
      }
      if (ComplexityInFunctions != 0) {
        size += 1 + pb::CodedOutputStream.ComputeInt32Size(ComplexityInFunctions);
      }
      if (FileComplexityDistribution.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FileComplexityDistribution);
      }
      if (FunctionComplexityDistribution.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FunctionComplexityDistribution);
      }
      size += noSonarComment_.CalculateSize(_repeated_noSonarComment_codec);
      size += nonBlankComment_.CalculateSize(_repeated_nonBlankComment_codec);
      size += codeLine_.CalculateSize(_repeated_codeLine_codec);
      return size;
    }

    public void MergeFrom(MetricsInfo other) {
      if (other == null) {
        return;
      }
      if (other.FilePath.Length != 0) {
        FilePath = other.FilePath;
      }
      if (other.LineCount != 0) {
        LineCount = other.LineCount;
      }
      if (other.ClassCount != 0) {
        ClassCount = other.ClassCount;
      }
      if (other.StatementCount != 0) {
        StatementCount = other.StatementCount;
      }
      if (other.FunctionCount != 0) {
        FunctionCount = other.FunctionCount;
      }
      if (other.PublicApiCount != 0) {
        PublicApiCount = other.PublicApiCount;
      }
      if (other.PublicUndocumentedApiCount != 0) {
        PublicUndocumentedApiCount = other.PublicUndocumentedApiCount;
      }
      if (other.Complexity != 0) {
        Complexity = other.Complexity;
      }
      if (other.ComplexityInClasses != 0) {
        ComplexityInClasses = other.ComplexityInClasses;
      }
      if (other.ComplexityInFunctions != 0) {
        ComplexityInFunctions = other.ComplexityInFunctions;
      }
      if (other.FileComplexityDistribution.Length != 0) {
        FileComplexityDistribution = other.FileComplexityDistribution;
      }
      if (other.FunctionComplexityDistribution.Length != 0) {
        FunctionComplexityDistribution = other.FunctionComplexityDistribution;
      }
      noSonarComment_.Add(other.noSonarComment_);
      nonBlankComment_.Add(other.nonBlankComment_);
      codeLine_.Add(other.codeLine_);
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            FilePath = input.ReadString();
            break;
          }
          case 16: {
            LineCount = input.ReadInt32();
            break;
          }
          case 24: {
            ClassCount = input.ReadInt32();
            break;
          }
          case 32: {
            StatementCount = input.ReadInt32();
            break;
          }
          case 40: {
            FunctionCount = input.ReadInt32();
            break;
          }
          case 48: {
            PublicApiCount = input.ReadInt32();
            break;
          }
          case 56: {
            PublicUndocumentedApiCount = input.ReadInt32();
            break;
          }
          case 64: {
            Complexity = input.ReadInt32();
            break;
          }
          case 72: {
            ComplexityInClasses = input.ReadInt32();
            break;
          }
          case 80: {
            ComplexityInFunctions = input.ReadInt32();
            break;
          }
          case 90: {
            FileComplexityDistribution = input.ReadString();
            break;
          }
          case 98: {
            FunctionComplexityDistribution = input.ReadString();
            break;
          }
          case 106:
          case 104: {
            noSonarComment_.AddEntriesFrom(input, _repeated_noSonarComment_codec);
            break;
          }
          case 114:
          case 112: {
            nonBlankComment_.AddEntriesFrom(input, _repeated_nonBlankComment_codec);
            break;
          }
          case 122:
          case 120: {
            codeLine_.AddEntriesFrom(input, _repeated_codeLine_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  ///  Issues
  /// </summary>
  [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
  public sealed partial class FileIssues : pb::IMessage<FileIssues> {
    private static readonly pb::MessageParser<FileIssues> _parser = new pb::MessageParser<FileIssues>(() => new FileIssues());
    public static pb::MessageParser<FileIssues> Parser { get { return _parser; } }

    public static pbr::MessageDescriptor Descriptor {
      get { return global::SonarAnalyzer.Protobuf.AnalyzerReportReflection.Descriptor.MessageTypes[5]; }
    }

    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    public FileIssues() {
      OnConstruction();
    }

    partial void OnConstruction();

    public FileIssues(FileIssues other) : this() {
      filePath_ = other.filePath_;
      issue_ = other.issue_.Clone();
    }

    public FileIssues Clone() {
      return new FileIssues(this);
    }

    /// <summary>Field number for the "file_path" field.</summary>
    public const int FilePathFieldNumber = 1;
    private string filePath_ = "";
    public string FilePath {
      get { return filePath_; }
      set {
        filePath_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "issue" field.</summary>
    public const int IssueFieldNumber = 2;
    private static readonly pb::FieldCodec<global::SonarAnalyzer.Protobuf.FileIssues.Types.Issue> _repeated_issue_codec
        = pb::FieldCodec.ForMessage(18, global::SonarAnalyzer.Protobuf.FileIssues.Types.Issue.Parser);
    private readonly pbc::RepeatedField<global::SonarAnalyzer.Protobuf.FileIssues.Types.Issue> issue_ = new pbc::RepeatedField<global::SonarAnalyzer.Protobuf.FileIssues.Types.Issue>();
    public pbc::RepeatedField<global::SonarAnalyzer.Protobuf.FileIssues.Types.Issue> Issue {
      get { return issue_; }
    }

    public override bool Equals(object other) {
      return Equals(other as FileIssues);
    }

    public bool Equals(FileIssues other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (FilePath != other.FilePath) return false;
      if(!issue_.Equals(other.issue_)) return false;
      return true;
    }

    public override int GetHashCode() {
      int hash = 1;
      if (FilePath.Length != 0) hash ^= FilePath.GetHashCode();
      hash ^= issue_.GetHashCode();
      return hash;
    }

    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    public void WriteTo(pb::CodedOutputStream output) {
      if (FilePath.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(FilePath);
      }
      issue_.WriteTo(output, _repeated_issue_codec);
    }

    public int CalculateSize() {
      int size = 0;
      if (FilePath.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(FilePath);
      }
      size += issue_.CalculateSize(_repeated_issue_codec);
      return size;
    }

    public void MergeFrom(FileIssues other) {
      if (other == null) {
        return;
      }
      if (other.FilePath.Length != 0) {
        FilePath = other.FilePath;
      }
      issue_.Add(other.issue_);
    }

    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            FilePath = input.ReadString();
            break;
          }
          case 18: {
            issue_.AddEntriesFrom(input, _repeated_issue_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the FileIssues message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
    public static partial class Types {
      [global::System.Diagnostics.DebuggerNonUserCodeAttribute()]
      public sealed partial class Issue : pb::IMessage<Issue> {
        private static readonly pb::MessageParser<Issue> _parser = new pb::MessageParser<Issue>(() => new Issue());
        public static pb::MessageParser<Issue> Parser { get { return _parser; } }

        public static pbr::MessageDescriptor Descriptor {
          get { return global::SonarAnalyzer.Protobuf.FileIssues.Descriptor.NestedTypes[0]; }
        }

        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        public Issue() {
          OnConstruction();
        }

        partial void OnConstruction();

        public Issue(Issue other) : this() {
          id_ = other.id_;
          message_ = other.message_;
          Location = other.location_ != null ? other.Location.Clone() : null;
        }

        public Issue Clone() {
          return new Issue(this);
        }

        /// <summary>Field number for the "id" field.</summary>
        public const int IdFieldNumber = 1;
        private string id_ = "";
        public string Id {
          get { return id_; }
          set {
            id_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "message" field.</summary>
        public const int MessageFieldNumber = 2;
        private string message_ = "";
        public string Message {
          get { return message_; }
          set {
            message_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
          }
        }

        /// <summary>Field number for the "location" field.</summary>
        public const int LocationFieldNumber = 3;
        private global::SonarAnalyzer.Protobuf.TextRange location_;
        public global::SonarAnalyzer.Protobuf.TextRange Location {
          get { return location_; }
          set {
            location_ = value;
          }
        }

        public override bool Equals(object other) {
          return Equals(other as Issue);
        }

        public bool Equals(Issue other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Id != other.Id) return false;
          if (Message != other.Message) return false;
          if (!object.Equals(Location, other.Location)) return false;
          return true;
        }

        public override int GetHashCode() {
          int hash = 1;
          if (Id.Length != 0) hash ^= Id.GetHashCode();
          if (Message.Length != 0) hash ^= Message.GetHashCode();
          if (location_ != null) hash ^= Location.GetHashCode();
          return hash;
        }

        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        public void WriteTo(pb::CodedOutputStream output) {
          if (Id.Length != 0) {
            output.WriteRawTag(10);
            output.WriteString(Id);
          }
          if (Message.Length != 0) {
            output.WriteRawTag(18);
            output.WriteString(Message);
          }
          if (location_ != null) {
            output.WriteRawTag(26);
            output.WriteMessage(Location);
          }
        }

        public int CalculateSize() {
          int size = 0;
          if (Id.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Id);
          }
          if (Message.Length != 0) {
            size += 1 + pb::CodedOutputStream.ComputeStringSize(Message);
          }
          if (location_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Location);
          }
          return size;
        }

        public void MergeFrom(Issue other) {
          if (other == null) {
            return;
          }
          if (other.Id.Length != 0) {
            Id = other.Id;
          }
          if (other.Message.Length != 0) {
            Message = other.Message;
          }
          if (other.location_ != null) {
            if (location_ == null) {
              location_ = new global::SonarAnalyzer.Protobuf.TextRange();
            }
            Location.MergeFrom(other.Location);
          }
        }

        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                Id = input.ReadString();
                break;
              }
              case 18: {
                Message = input.ReadString();
                break;
              }
              case 26: {
                if (location_ == null) {
                  location_ = new global::SonarAnalyzer.Protobuf.TextRange();
                }
                input.ReadMessage(location_);
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  #endregion

}

#endregion Designer generated code
